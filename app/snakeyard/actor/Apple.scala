package snakeyard.actor

import play.api.libs.iteratee.Concurrent
import scala.util.Random
import akka.actor.Props
import akka.actor.Actor
import akka.actor.ActorRef

object NewApple
case class Eat(coordinates: Int)

/**
 * Factory for [[snakeyard.actor.Apple]] instances. 
 * 
 * Apple coordinates are generated by a random generator passed as an argument upon actor's creation.
 * Apple's cell is sent to already opened web socket, also sent upon actor's creation. 
 */
object Apple {
  def props(randomGenerator: Random, webSocketChannel: ActorRef): Props = Props(new Apple(randomGenerator, webSocketChannel))
}

/**
 * Currently only one apple is one apple is generated and kept as a single coordinate(row*column) as internal state.
 * But the class easily can be extended to generate more than one apple when needed.
 *
 * Apple actor can: 
 *   issue a new apple (NewApple message)
 *   mark apple as eaten when a snake reaches apple's coordinates(Eat(coordinates) message)
 *   when snake's head is not on apple's coordinates, apple will stay untouched(StayHungry) 

 * @param randomGenerator - used to generate a new apple when the apple is eaten
 * @param webSocketChannel - used when a new apple is issued. The new apple is sent in the following protocol:
 * "APPLE:newAppleCoordinates"
 * 
 */
class Apple(randomGenerator: Random, webSocketChannel: ActorRef) extends Actor {
  var apple: Int = randomCell
  var channels: List[Concurrent.Channel[String]] = List()
  def receive = {
    case NewApple => {
      apple = randomCell
      webSocketChannel ! Send("APPLE:" + apple.toString)
    }
    case Eat(coordinates) => {
      if (apple != coordinates) {
        sender ! StayHungry
      } else {
        self ! NewApple
        sender ! Grow
      }
    }
  }
  def randomCell(): Int = {
    randomGenerator.nextInt(SnakePoolConfig.row * SnakePoolConfig.col - 1) + 1
  }
}